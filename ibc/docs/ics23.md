# ICS-23 Vector Commitments <!-- omit in toc -->

- [Overview](#overview)
- [Implementation](#implementation)
  - [Custom SMT `ProofSpec`](#custom-smt-proofspec)
  - [Converting `SparseMerkleProof` to `CommitmentProof`](#converting-sparsemerkleproof-to-commitmentproof)
  - [Proof Verification](#proof-verification)

## Overview

[ICS-23][ics23] defines the types and functions needed to verify membership of a key-value pair in a `CommitmentState`. As the Pocket IBC implementation uses the [SMT][smt] for its provable stores this is what is referred to as the `CommitmentState` object. Cosmos has a library `cosmos/ics23` which is already SDK agnostic and defines many of the types necessary for ICS-23. This library was able to be used _mostly_ out of the box, with some minor adjustments detailed below.

## Implementation

The benefit of using `cosmos/ics23` over implementing similar types ourselves is twofold:

1. It is already SDK agnostic, so can be used by Pocket (a non-cosmos chain) without any issues.
2. The functions defined for proof verification are separate from the tree structures themselves
   - This means we do not need to interact with an SMT instance in order to verify proofs.

However, as the library is so heavily tied to the IAVL tree used by cosmos-sdk some changes in proof verification had to be implemented. Alongside these changes, a custom SMT `ProofSpec` had to be designed and a method of converting `SparseMerkleProof` objects to `CommitmentProof` objects had to be implemented.

### Custom SMT `ProofSpec`

The `ProofSpec` type in `cosmos/ics23` is used to define the steps needed to verify a proof, what hashing functions should be used, any node prefixes, etc. This is then passed into the verification functions in order to verify a proof, instead of having to interact with the tree itself. This is useful as proofs must be verified on a light-client and as such being able to verify a proof without creating a tree is much more memory efficient.

As the SMT used by Pocket Network only stores hashed values by default, the IBC stores use the `WithValueHasher(nil)` option which stores the raw bytes of the values in the tree. As such the following `ProofSpec` was created:

```go
smtSpec *ics23.ProofSpec = &ics23.ProofSpec{
	LeafSpec: &ics23.LeafOp{
		Hash:         ics23.HashOp_SHA256,
		PrehashKey:   ics23.HashOp_SHA256,
		PrehashValue: ics23.HashOp_NO_HASH,
		Length:       ics23.LengthOp_NO_PREFIX,
        Prefix:       []byte{0},
	},
	InnerSpec: &ics23.InnerSpec{
		ChildOrder:      []int32{0, 1},
		ChildSize:       32,
		MinPrefixLength: 1,
		MaxPrefixLength: 1,
        EmptyChild:      make([]byte, 32),
		Hash:            ics23.HashOp_SHA256,
	},
	MaxDepth:                   256,
	PrehashKeyBeforeComparison: true,
}
```

The main change from the `cosmos/ics23` `SmtSpec` object is that the `PrehashValue` field is set to not hash values prior to hashing the key-value pair.

### Converting `SparseMerkleProof` to `CommitmentProof`

In order to convert the proofs generated by the SMT into a serialisable proof used by `cosmos/ics23`, the `SideNodes` field of the `SparseMerkleProof` must be converted into a list of `InnerOp` types which define the order of the hashes. The order of the hashes is important as depending on whether the next hash is the left or right neighbour of the current hash, they will be hashed in a different order, ultimately creating a different root hash. This conversion allows the verification to produce the same root hash as the SMT would have produced when verifying the proof.

### Proof Verification

As the IAVL tree indexes its keys, and the cosmos ecosystem utilise this tree, the `cosmos/ics23` library assumes this is the case in general. However, the SMT does not. This presents an issue for non-membership proofs, specifically the `ics23.NonExistenceProof` type. This essentially proves a range, such that the key we are looking for is not found in the range. This is not possible with the SMT in an efficient manner. Instead the SMT does non-membership proofs by instead proving the existence of an unrelated key-value pair in the place of where the key we are looking should be, or that the key-value pair is the default nil value.

Because of this distinction for both membership and non-membership proofs, the Pocket implementation of ICS-23 provides an existence proof (`ics23.ExistenceProof`). And instead either proves the existence of a default valued key, or that the key-value pair found is not the key-value pair we are looking for.

The high level logic for this is as follows:

```go
func VerifyNonMembership(root *coreTypes.CommitmentRoot, proof *ics23.CommitmentProof, key []byte) bool {
	// Verify the proof of the non-membership data doesn't belong to the key
	valid := ics23.VerifyMembership(smtSpec, root.Hash, proof, key, proof.GetExist().GetValue())
	// Verify the key was actually empty
	if bytes.Equal(proof.GetExist().GetValue(), defaultValue) {
		return valid
	}
	// Verify the key was present with unrelated data
	return !valid
}
```

The full implementation of this logic can be found [here](../stores/proofs_ics23.go).

[ics23]: https://github.com/cosmos/ibc/blob/main/spec/core/ics-023-vector-commitments/README.md
[smt]: https://github.com/pokt-network/smt
