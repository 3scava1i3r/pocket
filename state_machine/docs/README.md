# State Machine Module <!-- omit in toc -->

> ⚠️ Work in progress ⚠️ - At the time of writing this document, the architecture is still being defined.
>
> This is pretty much a POC at the moment.

This document outlines the purpose of this module, its components and how they all interact with the other modules.

## Contents <!-- omit in toc -->
- [Overview](#overview)
- [Code Structure](#code-structure)
- [High Level Architecture](#high-level-architecture)
  - [FSM primer](#fsm-primer)
- [Current State Machine Definition](#current-state-machine-definition)

## Overview

The `StateMachine` module implements a FSM (Finite State Machine) that is responsible for managing the node lifecycle since its internal behaviour can be different depending on certain conditions that are used to determine the current state.

In a nutshell: The FSM guarantees that the node is always in one specific state and verifies state transition (i.e. edges) to/from valid states (i.e. vertices).

## Code Structure

```bash
├── docs
│   ├── CHANGELOG.md              # Changelog
│   ├── README.md                 # You are here
│   └── state-machine.diagram.md  # State machine diagram (generated by visualizer/main.go)
├── fsm.go                        # Finite State Machine definition (events, states, transitions)
├── module.go                     # Implementation of the StateMachine module
└── visualizer
    └── main.go                   # State machine diagram generator
```

## High Level Architecture

High-level implementation details:

- The [github.com/looplab/fsm](https://github.com/looplab/fsm) library is used to implement the FSM
- Pocket builds a wrapper around `looplab/fsm` to integrate with the other modules
- The `StateMachineModule` can be accessed via the `bus` from any other `IntegratableModule`
- State machine transitions emit `StateMachineTransitionEvent` events that subscribed pocket modules can listen to
- The `node` has a central [event handler](../../shared/node.go) for events that fan-out event handling to the relevant modules during state transitions

### FSM primer

The FSM has a declarative definition of an initial state and a set of transitions that have an `Event`, `Source` states and a single `Destination` state.

These are the main building blocks:

- **Event**: An event is a string that represents an action that can trigger a transition. For example, the event `start` can be used to trigger a transition from the `stopped` state to the `starting` state.
- **State**: A state is a string that represents a state that the FSM can be in. For example, the state `stopped` can be used to represent a state where the node is not running.
- **Callback**: A callback is a function that is called when a transition occurs. For example, a callback can be used to log the transition or to perform some other action. Various types of callbacks essentially drive behaviour **WHEN** they are called and help build more complex behaviours like transition cancelling, etc. See the core FSM library documentation for more details.

## Current State Machine Definition

A diagram of the current state machine definition can be found [here](state-machine.diagram.md)
If you make any changes to it, you can re-generate it via:

```bash
make generate_node_state_machine_diagram
```


## State Machine Lifecycle
Node FSM starts from stopped state, and transitions to the bootstapping state, which is handled by the P2P module. In bootstrapping state, the node fills its address book, and upon completing mode transitions to unsynched state. Node's FSM moves to sync mode to start requesting block metadata and receive the blocks it is missing. Upon completing state sync in sync mode; if the node is a validator FSM transitions to pacemaker state and starts participating in the consensus state, else if the node is non-validator, FSM moves to the synced state. However, it is important to node that the non-validator node practically always stays in the snyc mode to keep getting blocks from the peers. The node may transition to unsynched state if it stays behind, i.e. in pacemaker mode if the node receives a block proposal which is higher than it's current height.

<!-- GITHUB_WIKI: state_machine/README -->
